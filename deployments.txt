Objects will always have a name and a type Kind -> type of object
updates are doen to the original config file
if the object name is changed, a new object will be created

after the image to be pull and configurations is completed:
simplek8 % kubectl apply -f client-pod.yaml

get information on a running pod:
kubectl describe <object type> <object name>
kubectl describe pod client-pod

update config file -> verify its all working correctly, same process

change from pod to deployments
deployments have/manages multiples/sets of pods
pods only usually used in dev environments

deployment will attempt to restart pods when issues arise

deployments are the production grade objects and pod management
deployments have pod templates -> used to create pods

deployment configuration files: -> client deployment.yaml

api version and deployment kind, metadata names it: client-deployment
spec section -> template lists out the details of the pods going to be created and
the containers to be created by pulling docker images

replicas -> the number of pods to be created

selector -> reaches out to the kubeapi to create the pod, when thats completed the pod will come back with the specified label, the pod can be located with the label, helpful for when you want your pod to be looking for specific components

kubectl get pods
kubectl delete -f configfile
kubectl apply -f client-deployment.yaml
kubectl get deployments
kubectl delete deployment client-deployment  

kubectl get pods vs kubectl get deployments -> changing the objects were are looking for

kubectl get pods -o wide

ip and node, created pods get ip address, service is necessary to be a consistent ip address
to connect to, pod ip address change all the time when recreated
service will automatically reroute traffic based on the selector to new/created pods
services give consistent access to pods

kubectl describe pods <optional name of the pod>

When a change to the image is made:
docker build -t jbur645/multicontainerdeploy-client . <-- dot is important
docker push jbur645/multicontainerdeploy-client
workflow to update image changes

most difficult aspect is convincing the deployment to update with the new image:
if kubectl doesnt pick up on any changes it will reject the image you want it to update to

imperative update command:
kubectl set image <object type>/<object name><container_name>=<updated_image_to use>
kubectl set image deployment/client-deployment client=jbur645/multicontainerdeploy-client:latest



